<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D Portal Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
            color: #fff; 
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            perspective: 2000px;
            position: relative;
        }

        /* Dark Silicon Glass Background with Grid */
        .silicon-background {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 255, 0.03) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a2a 30%, #0f0f1f 70%, #0a0a0a 100%);
            backdrop-filter: blur(1px);
            z-index: -2;
        }

        .silicon-background::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridShift 20s linear infinite;
            z-index: -1;
        }

        @keyframes gridShift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Main Portal Container */
        .portal-viewer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
        }

        /* Portal Window */
        .visualization-portal {
            position: relative;
            width: 85vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 800px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.2),
                0 0 100px rgba(255, 0, 255, 0.1),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            overflow: hidden;
            cursor: pointer;
        }

        .visualization-portal:hover {
            transform: scale(1.08) translateZ(30px);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 
                0 0 80px rgba(0, 255, 255, 0.4),
                0 0 150px rgba(255, 0, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
        }

        /* RGB Flash Effect */
        .visualization-portal::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                calc(45deg + (var(--mouse-x, 50) - 50) * 1.2deg),
                transparent 15%,
                rgba(0, 255, 255, 0.2) 40%,
                rgba(255, 0, 255, 0.25) 50%,
                rgba(255, 100, 0, 0.2) 60%,
                transparent 85%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: 18px;
            mix-blend-mode: screen;
        }

        .visualization-portal:hover::after {
            opacity: 1;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 18px;
            overflow: hidden;
        }

        /* VIB34D Engine Canvases */
        .engine-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            border-radius: 18px;
        }

        /* Audio Toggle (Top Right) */
        .audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .audio-toggle:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .audio-toggle.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
            color: #ffffff;
        }

        /* Minimal Info Display */
        .info-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 12px;
            backdrop-filter: blur(5px);
            z-index: 100;
            font-family: 'Orbitron', monospace;
        }

        .info-display h3 {
            margin: 0 0 8px 0;
            color: #00ffff;
            font-size: 14px;
        }

        .info-display p {
            margin: 3px 0;
            color: #ccc;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .visualization-portal {
                width: 95vw;
                height: 85vh;
                border-radius: 15px;
            }
            
            .audio-toggle {
                top: 15px;
                right: 15px;
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .info-display {
                bottom: 15px;
                left: 15px;
                padding: 12px 15px;
                font-size: 11px;
            }
        }

        /* Loading State */
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            z-index: 10;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 2px solid transparent;
            border-top: 2px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="silicon-background"></div>
    
    <div class="portal-viewer">
        <div class="visualization-portal" id="portalWindow">
            <div class="canvas-container">
                <!-- VIB34D Engine Canvas Layers -->
                <canvas id="background-canvas" class="engine-canvas"></canvas>
                <canvas id="shadow-canvas" class="engine-canvas"></canvas>
                <canvas id="content-canvas" class="engine-canvas"></canvas>
                <canvas id="highlight-canvas" class="engine-canvas"></canvas>
                <canvas id="accent-canvas" class="engine-canvas"></canvas>
                <div class="loading" id="loadingIndicator">Initializing Portal Engine...</div>
            </div>
        </div>
    </div>

    <button class="audio-toggle" id="audioToggle">ðŸŽµ Audio Reactive</button>
    
    <div class="info-display" id="infoDisplay">
        <h3>Portal Parameters</h3>
        <p id="systemType">System: Loading...</p>
        <p id="geometryInfo">Geometry: Loading...</p>
        <p id="configInfo">Configuration: Loading...</p>
    </div>

    <script type="module">
        // Import system-specific visualizers from VIB34D engine
        import { IntegratedHolographicVisualizer } from './src/core/Visualizer.js';
        import { QuantumHolographicVisualizer } from './src/quantum/QuantumVisualizer.js';
        import { HolographicVisualizer } from './src/holograms/HolographicVisualizer.js';
        
        class PortalEngine {
            constructor() {
                this.portalWindow = document.getElementById('portalWindow');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                
                this.visualizers = [];
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                this.clickIntensity = 0.0;
                this.audioReactive = false;
                this.audioData = null;
                
                // Portal expansion state
                this.isExpanded = false;
                this.tiltX = 0;
                this.tiltY = 0;
                
                // Parameters from URL
                this.params = this.parseUrlParameters();
                this.updateInfoDisplay();
                
                this.init();
            }
            
            async init() {
                try {
                    await this.setupCanvases();
                    await this.createEngineVisualizers();
                    this.setupPortalInteractions();
                    this.setupEventHandlers();
                    
                    this.loadingIndicator.style.display = 'none';
                    this.startRenderLoop();
                    
                    console.log('ðŸŽ¨ Portal engine initialized with VIB34D visualizers');
                } catch (error) {
                    console.error('âŒ Portal engine initialization failed:', error);
                    this.loadingIndicator.textContent = 'Failed to initialize portal engine';
                }
            }
            
            async setupCanvases() {
                const rect = this.portalWindow.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                
                const canvases = ['background-canvas', 'shadow-canvas', 'content-canvas', 'highlight-canvas', 'accent-canvas'];
                
                canvases.forEach(canvasId => {
                    const canvas = document.getElementById(canvasId);
                    if (canvas) {
                        canvas.width = rect.width * dpr;
                        canvas.height = rect.height * dpr;
                        canvas.style.width = rect.width + 'px';
                        canvas.style.height = rect.height + 'px';
                    }
                });
            }
            
            async createEngineVisualizers() {
                // Create system-specific visualizers based on URL system parameter
                console.log(`ðŸ” Creating visualizers for system: ${this.params.system}`);
                
                const layers = [
                    { id: 'background-canvas', role: 'background', reactivity: 0.5, variant: 0 },
                    { id: 'shadow-canvas', role: 'shadow', reactivity: 0.7, variant: 1 },
                    { id: 'content-canvas', role: 'content', reactivity: 0.9, variant: 2 },
                    { id: 'highlight-canvas', role: 'highlight', reactivity: 1.1, variant: 3 },
                    { id: 'accent-canvas', role: 'accent', reactivity: 1.5, variant: 4 }
                ];
                
                let successfulLayers = 0;
                
                for (const layer of layers) {
                    try {
                        const canvas = document.getElementById(layer.id);
                        if (!canvas) {
                            console.error(`âŒ Canvas not found: ${layer.id}`);
                            continue;
                        }
                        
                        console.log(`ðŸ” Creating ${this.params.system} visualizer for: ${layer.id}`);
                        let visualizer;
                        
                        // Create system-specific visualizer
                        switch (this.params.system) {
                            case 'quantum':
                                visualizer = new QuantumHolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                            case 'holographic':
                                visualizer = new HolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                            case 'faceted':
                            default:
                                visualizer = new IntegratedHolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                        }
                        
                        if (visualizer && visualizer.gl) {
                            // Apply current parameters to visualizer
                            this.applyParametersToVisualizer(visualizer);
                            
                            this.visualizers.push(visualizer);
                            successfulLayers++;
                            console.log(`âœ… Created ${this.params.system} layer: ${layer.role} (${layer.id})`);
                        } else {
                            console.error(`âŒ No WebGL context for: ${layer.id}`);
                        }
                    } catch (error) {
                        console.error(`âŒ Failed to create ${this.params.system} layer ${layer.id}:`, error);
                    }
                }
                
                console.log(`âœ… Created ${successfulLayers}/5 ${this.params.system} engine layers`);
            }
            
            applyParametersToVisualizer(visualizer) {
                // Apply URL parameters to the visualizer using consistent parameter names
                if (visualizer.updateParameters) {
                    const standardParams = {
                        geometry: this.params.geometryType,
                        gridDensity: this.params.density,
                        morphFactor: this.params.morph,
                        chaos: this.params.chaos,
                        speed: this.params.speed,
                        hue: this.params.hue,
                        intensity: this.params.intensity,
                        saturation: this.params.saturation,
                        rot4dXW: this.params.rot4dXW,
                        rot4dYW: this.params.rot4dYW,
                        rot4dZW: this.params.rot4dZW
                    };
                    
                    console.log(`ðŸ”§ Applying parameters to ${this.params.system} visualizer:`, standardParams);
                    visualizer.updateParameters(standardParams);
                } else if (visualizer.setParameters) {
                    // Alternative parameter setting method
                    visualizer.setParameters({
                        geometry: this.params.geometryType,
                        gridDensity: this.params.density,
                        morphFactor: this.params.morph,
                        chaos: this.params.chaos,
                        speed: this.params.speed,
                        hue: this.params.hue,
                        intensity: this.params.intensity,
                        saturation: this.params.saturation
                    });
                } else {
                    console.warn(`âš ï¸ No parameter setting method found for ${this.params.system} visualizer`);
                }
            }
            
            setupPortalInteractions() {
                // Enhanced mouse tracking for portal expansion and tilt effects
                this.portalWindow.addEventListener('mousemove', (e) => {
                    const rect = this.portalWindow.getBoundingClientRect();
                    this.mouseX = (e.clientX - rect.left) / rect.width;
                    this.mouseY = 1 - (e.clientY - rect.top) / rect.height;
                    
                    // Calculate tilt based on mouse position (more dramatic when expanded)
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const maxTilt = this.isExpanded ? 25 : 10; // More tilt when expanded
                    
                    this.tiltX = ((e.clientX - rect.left - centerX) / centerX) * maxTilt;
                    this.tiltY = ((e.clientY - rect.top - centerY) / centerY) * -maxTilt;
                    
                    // Update portal visual tilt
                    this.updatePortalTilt();
                    
                    // Update CSS custom properties for RGB flash
                    document.documentElement.style.setProperty('--mouse-x', this.mouseX * 100);
                    document.documentElement.style.setProperty('--mouse-y', this.mouseY * 100);
                    
                    // Update engine mouse reactivity
                    this.updateEngineReactivity();
                });
                
                // Portal expansion on hover
                this.portalWindow.addEventListener('mouseenter', () => {
                    this.isExpanded = true;
                    this.mouseIntensity = 1.0;
                });
                
                this.portalWindow.addEventListener('mouseleave', () => {
                    this.isExpanded = false;
                    this.mouseIntensity = 0.0;
                    this.tiltX = 0;
                    this.tiltY = 0;
                    this.updatePortalTilt();
                });
                
                // Click effects
                this.portalWindow.addEventListener('mousedown', () => {
                    this.clickIntensity = 1.0;
                });
                
                this.portalWindow.addEventListener('mouseup', () => {
                    this.clickIntensity = 0.0;
                });
            }
            
            updatePortalTilt() {
                const portal = this.portalWindow;
                const scaleValue = this.isExpanded ? 1.08 : 1.0;
                const zValue = this.isExpanded ? 30 : 0;
                
                portal.style.transform = `
                    scale(${scaleValue}) 
                    translateZ(${zValue}px) 
                    rotateX(${this.tiltY}deg) 
                    rotateY(${this.tiltX}deg)
                `;
            }
            
            updateEngineReactivity() {
                // Update all visualizers with current mouse state
                this.visualizers.forEach(visualizer => {
                    if (visualizer.updateMouse) {
                        visualizer.updateMouse(this.mouseX, this.mouseY, this.mouseIntensity);
                    }
                    if (visualizer.updateClick) {
                        visualizer.updateClick(this.clickIntensity);
                    }
                });
            }
            
            setupEventHandlers() {
                // Audio toggle
                document.getElementById('audioToggle').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvases();
                });
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'f' || e.key === 'F') {
                        this.toggleFullscreen();
                    }
                });
            }
            
            toggleAudio() {
                const button = document.getElementById('audioToggle');
                this.audioReactive = !this.audioReactive;
                
                if (this.audioReactive) {
                    button.classList.add('active');
                    button.textContent = 'ðŸŽµ Audio ON';
                    this.initAudio();
                } else {
                    button.classList.remove('active');
                    button.textContent = 'ðŸŽµ Audio OFF';
                }
            }
            
            async initAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new AudioContext();
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    
                    this.audioData = new Uint8Array(analyser.frequencyBinCount);
                    this.audioAnalyser = analyser;
                    
                    console.log('ðŸŽµ Audio reactive mode enabled');
                } catch (error) {
                    console.warn('Audio access denied:', error);
                    this.audioReactive = false;
                    document.getElementById('audioToggle').classList.remove('active');
                }
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            render() {
                // Get audio level if available
                let audioLevel = 0;
                if (this.audioReactive && this.audioAnalyser && this.audioData) {
                    this.audioAnalyser.getByteFrequencyData(this.audioData);
                    audioLevel = Array.from(this.audioData).reduce((a, b) => a + b, 0) / (this.audioData.length * 255);
                }
                
                // Render all VIB34D engine layers
                this.visualizers.forEach(visualizer => {
                    if (visualizer.render) {
                        visualizer.render();
                    }
                });
            }
            
            startRenderLoop() {
                const renderFrame = () => {
                    this.render();
                    requestAnimationFrame(renderFrame);
                };
                renderFrame();
            }
            
            parseUrlParameters() {
                const params = new URLSearchParams(window.location.search);
                
                // Enhanced parameter parsing with better fallbacks and normalized names
                const parsedParams = {
                    system: params.get('system') || 'faceted', // Default to faceted, not quantum
                    name: params.get('name') || 'Portal View',
                    
                    // Support both normalized (saved) and original parameter names
                    geometryType: parseInt(params.get('geometryType') || params.get('geometry')) || 0,
                    density: parseFloat(params.get('density') || params.get('gridDensity')) || 15,
                    morph: parseFloat(params.get('morph') || params.get('morphFactor')) || 1,
                    speed: parseFloat(params.get('speed')) || 1,
                    chaos: parseFloat(params.get('chaos')) || 0.2,
                    hue: parseFloat(params.get('hue')) || 200,
                    saturation: parseFloat(params.get('saturation')) || 0.8,
                    intensity: parseFloat(params.get('intensity')) || 0.8,
                    
                    // 4D rotation parameters
                    rot4dXW: parseFloat(params.get('rot4dXW')) || 0,
                    rot4dYW: parseFloat(params.get('rot4dYW')) || 0,
                    rot4dZW: parseFloat(params.get('rot4dZW')) || 0,
                    dimension: parseFloat(params.get('dimension')) || 3.5
                };
                
                console.log('ðŸ” Parsed URL parameters:', parsedParams);
                return parsedParams;
            }
            
            updateInfoDisplay() {
                const geometryNames = ['Tetrahedron', 'Hypercube', 'Sphere', 'Torus', 'Klein Bottle', 'Fractal', 'Wave', 'Crystal'];
                
                document.getElementById('systemType').textContent = `System: ${this.params.system.toUpperCase()}`;
                document.getElementById('geometryInfo').textContent = `Geometry: ${geometryNames[this.params.geometryType] || 'Unknown'}`;
                document.getElementById('configInfo').textContent = `Config: ${this.params.name}`;
            }
        }
        
        // Initialize portal engine when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PortalEngine();
        });
    </script>
</body>
</html>