<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D Portal Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
            color: #fff; 
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            perspective: 2000px;
            position: relative;
        }

        /* Dark Silicon Glass Background with Grid */
        .silicon-background {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 255, 0.03) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a2a 30%, #0f0f1f 70%, #0a0a0a 100%);
            backdrop-filter: blur(1px);
            z-index: -2;
        }

        .silicon-background::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridShift 20s linear infinite;
            z-index: -1;
        }

        @keyframes gridShift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Main Portal Container */
        .portal-viewer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
        }

        /* Portal Window */
        .visualization-portal {
            position: relative;
            width: 80vw;
            height: 80vh;
            max-width: 1000px;
            max-height: 700px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.2),
                0 0 100px rgba(255, 0, 255, 0.1),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            overflow: hidden;
            cursor: pointer;
        }

        .visualization-portal:hover {
            transform: scale(1.05) translateZ(20px);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 
                0 0 80px rgba(0, 255, 255, 0.4),
                0 0 150px rgba(255, 0, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
        }

        /* RGB Flash Effect */
        .visualization-portal::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                calc(45deg + (var(--mouse-x, 50) - 50) * 0.8deg),
                transparent 20%,
                rgba(0, 255, 255, 0.15) 45%,
                rgba(255, 0, 255, 0.2) 50%,
                rgba(255, 100, 0, 0.15) 55%,
                transparent 80%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: 18px;
        }

        .visualization-portal:hover::after {
            opacity: 1;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 18px;
            overflow: hidden;
        }

        /* Main Visualization Canvas */
        #mainCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            border-radius: 18px;
            transition: all 0.5s ease;
        }

        /* Mirror Canvas (Background Effect) */
        #mirrorCanvas {
            position: absolute;
            top: 50%; left: 50%;
            width: 120%;
            height: 120%;
            transform: translate(-50%, -50%) scale(0.8) rotateX(180deg);
            opacity: 0.1;
            filter: blur(2px) brightness(0.3);
            border-radius: 18px;
            z-index: -1;
        }

        /* Audio Toggle (Top Right) */
        .audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .audio-toggle:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .audio-toggle.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
            color: #ffffff;
        }

        /* Minimal Info Display */
        .info-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 12px;
            backdrop-filter: blur(5px);
            z-index: 100;
            font-family: 'Orbitron', monospace;
        }

        .info-display h3 {
            margin: 0 0 8px 0;
            color: #00ffff;
            font-size: 14px;
        }

        .info-display p {
            margin: 3px 0;
            color: #ccc;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .visualization-portal {
                width: 95vw;
                height: 85vh;
                border-radius: 15px;
            }
            
            .audio-toggle {
                top: 15px;
                right: 15px;
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .info-display {
                bottom: 15px;
                left: 15px;
                padding: 12px 15px;
                font-size: 11px;
            }
        }

        /* Loading State */
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            z-index: 10;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 2px solid transparent;
            border-top: 2px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="silicon-background"></div>
    
    <div class="portal-viewer">
        <div class="visualization-portal" id="portalWindow">
            <div class="canvas-container">
                <canvas id="mirrorCanvas"></canvas>
                <canvas id="mainCanvas"></canvas>
                <div class="loading" id="loadingIndicator">Initializing Portal...</div>
            </div>
        </div>
    </div>

    <button class="audio-toggle" id="audioToggle">ðŸŽµ Audio Reactive</button>
    
    <div class="info-display" id="infoDisplay">
        <h3>Portal Parameters</h3>
        <p id="systemType">System: Loading...</p>
        <p id="geometryInfo">Geometry: Loading...</p>
        <p id="configInfo">Configuration: Loading...</p>
    </div>

    <script type="module">
        class PortalViewer {
            constructor() {
                this.mainCanvas = document.getElementById('mainCanvas');
                this.mirrorCanvas = document.getElementById('mirrorCanvas');
                this.portalWindow = document.getElementById('portalWindow');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                
                this.gl = null;
                this.mirrorGl = null;
                this.program = null;
                this.mirrorProgram = null;
                
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.audioReactive = false;
                this.audioData = null;
                
                // Parameters from URL
                this.params = this.parseUrlParameters();
                this.updateInfoDisplay();
                
                this.init();
            }
            
            async init() {
                try {
                    await this.setupCanvases();
                    await this.initWebGL();
                    await this.setupEventHandlers();
                    
                    this.loadingIndicator.style.display = 'none';
                    this.startRenderLoop();
                    
                    console.log('ðŸŽ¨ Portal viewer initialized successfully');
                } catch (error) {
                    console.error('âŒ Portal viewer initialization failed:', error);
                    this.loadingIndicator.textContent = 'Failed to initialize portal';
                }
            }
            
            async setupCanvases() {
                const rect = this.portalWindow.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                
                // Main canvas
                this.mainCanvas.width = rect.width * dpr;
                this.mainCanvas.height = rect.height * dpr;
                this.mainCanvas.style.width = rect.width + 'px';
                this.mainCanvas.style.height = rect.height + 'px';
                
                // Mirror canvas (same size)
                this.mirrorCanvas.width = rect.width * dpr;
                this.mirrorCanvas.height = rect.height * dpr;
                this.mirrorCanvas.style.width = rect.width + 'px';
                this.mirrorCanvas.style.height = rect.height + 'px';
            }
            
            async initWebGL() {
                // Main canvas WebGL
                this.gl = this.mainCanvas.getContext('webgl2') || this.mainCanvas.getContext('webgl');
                if (!this.gl) throw new Error('WebGL not supported');
                
                // Mirror canvas WebGL  
                this.mirrorGl = this.mirrorCanvas.getContext('webgl2') || this.mirrorCanvas.getContext('webgl');
                if (!this.mirrorGl) throw new Error('Mirror WebGL not supported');
                
                // Create shader programs
                this.program = this.createShaderProgram(this.gl);
                this.mirrorProgram = this.createShaderProgram(this.mirrorGl);
                
                // Setup geometry for both canvases
                this.setupGeometry(this.gl, this.program);
                this.setupGeometry(this.mirrorGl, this.mirrorProgram);
                
                console.log('âœ… WebGL initialized for both canvases');
            }
            
            createShaderProgram(gl) {
                // Simple but effective vertex shader
                const vertexShaderSource = `
                    attribute vec2 position;
                    varying vec2 vUv;
                    void main() {
                        vUv = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
                
                // Enhanced fragment shader with holographic effects
                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec2 vUv;
                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;
                    uniform float geometryType;
                    uniform float density;
                    uniform float speed;
                    uniform float chaos;
                    uniform float morph;
                    uniform float hue;
                    uniform float saturation;
                    uniform float intensity;
                    uniform float audioLevel;
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    float lattice(vec3 p) {
                        vec3 q = fract(p * density) - 0.5;
                        float d = length(q);
                        return smoothstep(0.3, 0.1, d) * (1.0 + sin(time * speed + d * 10.0) * chaos);
                    }
                    
                    void main() {
                        vec2 uv = (vUv - 0.5) * 2.0;
                        uv.x *= resolution.x / resolution.y;
                        
                        float t = time * speed * 0.1;
                        vec3 p = vec3(uv, sin(t) * morph);
                        
                        // Mouse interaction with tilt effect
                        vec2 mouseOffset = (mouse - 0.5) * 2.0;
                        p.xy += mouseOffset * 0.3;
                        p.z += cos(mouseOffset.x) * sin(mouseOffset.y) * 0.5;
                        
                        // Create holographic lattice
                        float pattern = lattice(p);
                        pattern += lattice(p * 1.5 + vec3(t, -t, t * 0.5)) * 0.7;
                        pattern += lattice(p * 0.7 + vec3(-t * 0.3, t * 0.7, -t)) * 0.5;
                        
                        // Audio reactive enhancement
                        pattern *= (1.0 + audioLevel * 0.5);
                        
                        // Color with HSV control
                        float hueShift = hue / 360.0 + t * 0.1;
                        vec3 color = hsv2rgb(vec3(hueShift + pattern * 0.1, saturation, intensity));
                        
                        // RGB flash effect based on mouse position
                        vec3 flash = vec3(
                            sin(mouseOffset.x * 3.14159) * 0.3,
                            cos(mouseOffset.y * 3.14159) * 0.3,
                            sin(mouseOffset.x + mouseOffset.y) * 0.3
                        );
                        color += flash * pattern;
                        
                        // Holographic shimmer
                        float shimmer = sin(uv.x * 10.0 + t * 5.0) * sin(uv.y * 8.0 + t * 3.0) * 0.1;
                        color += vec3(shimmer);
                        
                        gl_FragColor = vec4(color, pattern * 0.8 + 0.2);
                    }
                `;
                
                const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Shader program failed to link: ' + gl.getProgramInfoLog(program));
                }
                
                return program;
            }
            
            compileShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
                }
                
                return shader;
            }
            
            setupGeometry(gl, program) {
                const vertices = new Float32Array([
                    -1, -1, 1, -1, -1, 1,
                    -1, 1, 1, -1, 1, 1
                ]);
                
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            }
            
            setupEventHandlers() {
                // Mouse tracking for tilt effect
                this.portalWindow.addEventListener('mousemove', (e) => {
                    const rect = this.portalWindow.getBoundingClientRect();
                    this.mouseX = (e.clientX - rect.left) / rect.width;
                    this.mouseY = 1 - (e.clientY - rect.top) / rect.height;
                    
                    // Update CSS custom properties for RGB flash
                    document.documentElement.style.setProperty('--mouse-x', this.mouseX * 100);
                    document.documentElement.style.setProperty('--mouse-y', this.mouseY * 100);
                });
                
                // Audio toggle
                document.getElementById('audioToggle').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvases();
                });
            }
            
            toggleAudio() {
                const button = document.getElementById('audioToggle');
                this.audioReactive = !this.audioReactive;
                
                if (this.audioReactive) {
                    button.classList.add('active');
                    button.textContent = 'ðŸŽµ Audio ON';
                    this.initAudio();
                } else {
                    button.classList.remove('active');
                    button.textContent = 'ðŸŽµ Audio OFF';
                }
            }
            
            async initAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new AudioContext();
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    
                    this.audioData = new Uint8Array(analyser.frequencyBinCount);
                    this.audioAnalyser = analyser;
                    
                    console.log('ðŸŽµ Audio reactive mode enabled');
                } catch (error) {
                    console.warn('Audio access denied:', error);
                    this.audioReactive = false;
                    document.getElementById('audioToggle').classList.remove('active');
                }
            }
            
            render() {
                const currentTime = Date.now() * 0.001;
                
                // Get audio level if available
                let audioLevel = 0;
                if (this.audioReactive && this.audioAnalyser && this.audioData) {
                    this.audioAnalyser.getByteFrequencyData(this.audioData);
                    audioLevel = Array.from(this.audioData).reduce((a, b) => a + b, 0) / (this.audioData.length * 255);
                }
                
                // Render main canvas
                this.renderCanvas(this.gl, this.program, currentTime, audioLevel, false);
                
                // Render mirror canvas (dimmed and inverted)
                this.renderCanvas(this.mirrorGl, this.mirrorProgram, currentTime, audioLevel * 0.3, true);
            }
            
            renderCanvas(gl, program, time, audioLevel, isMirror) {
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0, 0, 0, isMirror ? 0.1 : 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                gl.useProgram(program);
                
                // Set uniforms
                const timeLocation = gl.getUniformLocation(program, 'time');
                const mouseLocation = gl.getUniformLocation(program, 'mouse');
                const resolutionLocation = gl.getUniformLocation(program, 'resolution');
                const geometryTypeLocation = gl.getUniformLocation(program, 'geometryType');
                const densityLocation = gl.getUniformLocation(program, 'density');
                const speedLocation = gl.getUniformLocation(program, 'speed');
                const chaosLocation = gl.getUniformLocation(program, 'chaos');
                const morphLocation = gl.getUniformLocation(program, 'morph');
                const hueLocation = gl.getUniformLocation(program, 'hue');
                const saturationLocation = gl.getUniformLocation(program, 'saturation');
                const intensityLocation = gl.getUniformLocation(program, 'intensity');
                const audioLevelLocation = gl.getUniformLocation(program, 'audioLevel');
                
                gl.uniform1f(timeLocation, time);
                gl.uniform2f(mouseLocation, this.mouseX, this.mouseY);
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(geometryTypeLocation, this.params.geometryType || 0);
                gl.uniform1f(densityLocation, this.params.density || 15);
                gl.uniform1f(speedLocation, this.params.speed || 1);
                gl.uniform1f(chaosLocation, this.params.chaos || 0.2);
                gl.uniform1f(morphLocation, this.params.morph || 1);
                gl.uniform1f(hueLocation, this.params.hue || 200);
                gl.uniform1f(saturationLocation, this.params.saturation || 0.8);
                gl.uniform1f(intensityLocation, (this.params.intensity || 0.8) * (isMirror ? 0.3 : 1));
                gl.uniform1f(audioLevelLocation, audioLevel);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            
            startRenderLoop() {
                const renderFrame = () => {
                    this.render();
                    requestAnimationFrame(renderFrame);
                };
                renderFrame();
            }
            
            parseUrlParameters() {
                const params = new URLSearchParams(window.location.search);
                return {
                    system: params.get('system') || 'quantum',
                    name: params.get('name') || 'Portal View',
                    geometryType: parseInt(params.get('geometryType')) || 0,
                    density: parseFloat(params.get('density')) || 15,
                    speed: parseFloat(params.get('speed')) || 1,
                    chaos: parseFloat(params.get('chaos')) || 0.2,
                    morph: parseFloat(params.get('morph')) || 1,
                    hue: parseFloat(params.get('hue')) || 200,
                    saturation: parseFloat(params.get('saturation')) || 0.8,
                    intensity: parseFloat(params.get('intensity')) || 0.8,
                    rot4dXW: parseFloat(params.get('rot4dXW')) || 0,
                    rot4dYW: parseFloat(params.get('rot4dYW')) || 0,
                    rot4dZW: parseFloat(params.get('rot4dZW')) || 0,
                    dimension: parseFloat(params.get('dimension')) || 3.5
                };
            }
            
            updateInfoDisplay() {
                const geometryNames = ['Tetrahedron', 'Hypercube', 'Sphere', 'Torus', 'Klein Bottle', 'Fractal', 'Wave', 'Crystal'];
                
                document.getElementById('systemType').textContent = `System: ${this.params.system.toUpperCase()}`;
                document.getElementById('geometryInfo').textContent = `Geometry: ${geometryNames[this.params.geometryType] || 'Unknown'}`;
                document.getElementById('configInfo').textContent = `Config: ${this.params.name}`;
            }
        }
        
        // Initialize portal viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PortalViewer();
        });
    </script>
</body>
</html>